<!DOCTYPE html>

<link rel="import" href="/base/base.html">
<link rel="import" href="/model/card.html">
<link rel="import" href="/model/card_stack.html">
<link rel="import" href="/model/config.html">
<link rel="import" href="/model/player.html">

<script>

mm.exportTo('mm.m', function() {

  var Card = mm.m.Card;
  var CardStack= mm.m.CardStack;
  var Player = mm.m.Player;

  function Model(numPlayers) {
    var tempStack = new CardStack();
    mm.m.AddInitialCards(tempStack);
    tempStack.shuffle();

    this.stacks_ = [new CardStack(), new CardStack()];
    tempStack.distribute(this.stacks_);

    this.players_ = []
    for (var i = 0; i < numPlayers; ++i) {
      this.players_.push(new Player());
    }
  }

  Model.prototype = {
    format: function(prefix) {
      var output = '';
      for (var i = 0; i < this.stacks_.length; ++i) {      
        output += prefix + 'Stack ' + i + ':\n';
        output += this.stacks_[i].format(prefix + '  ');
      }
      for (var i = 0; i < this.players_.length; ++i) {
        output += prefix + 'Player ' + i + ':\n';
        output += this.players_[i].format(prefix + '  ');
      }
      return output;
    },

    isStackEmpty: function(stackIndex) {
      return this.stacks_.length <= stackIndex ||
          this.stacks_[stackIndex].length === 0;
    },

    isPlayerHandEmpty: function(playerIndex) {
      this.players_[playerIndex].isHandEmpty();
    },

    isPlayerHandCursed: function(playerIndex) {
      return this.players_[playerIndex].isHandCursed();
    },

    playerHandHasSymbol: function(playerIndex, symbol) {
      return this.players_[playerIndex].handHasSymbol(symbol);
    },

    topColors: function() {
      var result = [];
      for (var i = 0; i < this.stacks_.length; ++i) {
        var length = stacks_[i].length;
        if (length === 0)
          result.push(undefined);
        else
          result.push(this.stacks_[i][length - 1].color);
      }
      return result;
    },

    playerHandColors: function(playerIndex) {
      return this.players_[playerIndex].handColors();
    },

    playerDrawCard: function(playerIndex, stackIndex) {
      this.players_[playerIndex].addCardToHand(this.stacks_[stackIndex].pop());
    },

    computePlayerHandScore: function(playerIndex) {
      return this.players_[playerIndex].computeHandScore();
    },

    addToPlayerScore: function(playerIndex, score) {
      this.players_[playerIndex].addToScore(score);
    },

    playerScoreHand: function(playerIndex) {
      this.players_[playerIndex].scoreHand();
    },

    playerClearHand: function(playerIndex) {
      this.players_[playerIndex].clearHand();      
    }
  };

  return {
    Model: Model
  };
});

</script>
